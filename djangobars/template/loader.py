from django.template import Context, RequestContext
from django.template.base import TemplateDoesNotExist
from django.template.loader import (find_template_loader, BaseLoader,
                                    make_origin)

from .. import settings
from .base import HandlebarsTemplate
from .backends import Handlebars as HandlebarsEngine


template_source_loaders = None


class BaseHandlebarsLoader(BaseLoader):
    """
    Base loader for Handlebars templates. Just override the load_template method
    to use the get_template_from_string method in the djangobars.template.loader
    module instead of the one in the core Django template codebase.
    """

    def __init__(self, *args, **kwargs):
        self.engine_options = getattr(settings, 'HANDLEBARS_OPTS', {})
        self.engine = HandlebarsEngine({'OPTIONS': self.engine_options})
        return super(BaseLoader, self).__init__(*args, **kwargs)


    def load_template(self, template_name, template_dirs=None):
        template = self.engine.get_template(template_name, dirs=self)
        if template:
            return template, None

        source, display_name = self.load_template_source(template_name,
                                                         template_dirs)
        origin = make_origin(display_name, self.load_template_source,
                             template_name, template_dirs)
        try:
            template = self.engine.from_string(source, origin=origin, name=template_name)
            return template, None
        except TemplateDoesNotExist:
            # If compiling the template we found raises TemplateDoesNotExist,
            # back off to returning the source and display name for the template
            # we were asked to load. This allows for correct identification
            # (later) of the actual template that does not exist.
            return source, display_name


def reset_loaders():
    """
    For testing, reset cached loaders
    """
    global template_source_loaders
    template_source_loaders = None


def find_template(name, dirs=None):
    # Calculate template_source_loaders the first time the function is executed
    # because putting this logic in the module-level namespace may cause
    # circular import errors. See Django ticket #1292.
    global template_source_loaders
    if template_source_loaders is None:
        loaders = []
        for loader_name in settings.HANDLEBARS_LOADERS:
            loader = find_template_loader(loader_name)
            if loader is not None:
                loaders.append(loader)
        template_source_loaders = tuple(loaders)
    for loader in template_source_loaders:
        try:
            source, display_name = loader(name, dirs)
            return (source, make_origin(display_name, loader, name, dirs))
        except TemplateDoesNotExist:
            pass
    raise TemplateDoesNotExist(name)


def get_template(template_name):
    """
    Returns a compiled Template object for the given template name,
    handling template inheritance recursively.
    """
    template, origin = find_template(template_name)
    if not hasattr(template, 'render'):
        # template needs to be compiled
        template = get_template_from_string(template, origin, template_name)
    return template


def get_template_from_string(source, origin=None, name=None):
    """
    Returns a compiled Template object for the given template code,
    handling template inheritance recursively.
    """
    return HandlebarsTemplate(source, origin, name)


def select_template(template_name_list):
    "Given a list of template names, returns the first that can be loaded."
    if not template_name_list:
        raise TemplateDoesNotExist("No template names provided")
    not_found = []
    for template_name in template_name_list:
        try:
            return get_template(template_name)
        except TemplateDoesNotExist as e:
            if e.args[0] not in not_found:
                not_found.append(e.args[0])
            continue
    # If we get here, none of the templates could be loaded
    raise TemplateDoesNotExist(', '.join(not_found))


def render_to_string(template_name, dictionary=None, context_instance=None):
    """
    Loads the given template_name and renders it with the given dictionary as
    context. The template_name may be a string to load a single template using
    get_template, or it may be a tuple to use select_template to find one of
    the templates in the list. Returns a string.
    """
    dictionary = dictionary or {}
    if isinstance(template_name, (list, tuple)):
        t = select_template(template_name)
    else:
        t = get_template(template_name)
    if not context_instance:
        return t.render(Context(dictionary))
    # Add the dictionary to the context stack, ensuring it gets removed again
    # to keep the context_instance in the same state it started in.
    context_instance.update(dictionary)
    try:
        return t.render(context_instance)
    finally:
        context_instance.pop()
